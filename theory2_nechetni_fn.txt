НЕЧЕТНИ ФАКУЛТЕТНИ НОМЕРА

1. ХАРАКТЕРИЗИРАЙТЕ НАКРАТКО СТРУКТУРАТА ОТ ДАННИ "ОПАШКА".

Опашката е крайна редица от елементи от един и същ тип. Операцията включване на елемент е допустима само за 
единия (например десния) край на редицата, който се нарича край на опашката. Операцията изключване на елемент 
е допустима само за другия (левия) край на редицата, който се нарича начало на опашката. Възможен е пряк достъп 
само до елемента, намиращ се в началото на опашката. При описаната организация на логическите операции, последният 
включен в опашката елемент се изключва последен, а първият – първи. Затова опашката се определя още като структура 
от данни „пръв влязъл – пръв излязъл“ (first in – first out, FIFO).


2. КАК СЕ ДЕФИНИРАТ КЛАСОВЕ В HASKELL? ДАЙТЕ ПРИМЕР ЗА ДЕФИНИЦИЯ НА КЛАС.

Най-общо, понятието клас в езика Haskell се определя като колекция от типове, за които се поддържа множество додефинирани 
операции, наречени методи. Например, за функцията elem, която е „вградена“ в Haskell, може да се предположи, че е от тип elem :: a -> [a] -> Bool

Множеството (колекцията) от типове, за които са дефинирани съответно множество от функции, се нарича клас от/на типове (type class) 
или накратко клас.

Множеството от типове, за които е дефинирана функцията за проверка на равенство (==), се означава като клас Eq.
allEqual :: Eq a => a -> a -> a -> Bool
allEqual m n p = (m==n) && (n==p)

Дефиниции по подразбиране:

class Eq a where
(==), (/=) :: a -> a -> Bool
x /= y = not (x==y)
x == y = not (x/=y)

(Към операцията за сравнение с цел проверка на равенство се добавя и проверката за неравенство (различие). 
Освен това са включени и дефиниции по подразбиране на /= чрез == и на == чрез /=)


3. ОБЯСНЕТЕ СЪЩНОСТТА НА "МЪРЗЕЛИВОТО" ОЦЕНЯВАНЕ (LAZY EVALUATION) В ЕЗИКА HASKELL. ДАЙТЕ ПОНЕ ДВА ПРИМЕРА, КОИТО ИЛЮСТРИРАТ 
РАЗЛИЧНИ АСПЕКТИ НА "МЪРЗЕЛИВОТО" ОЦЕНЯВАНЕ (ВКЛЮЧИТЕЛНО ПРОСЛЕДЕТЕ СТЪПКА ПО СТЪПКА СЪОТВЕТНИТЕ ПРОЦЕСИ НА ОЦЕНЯВАНЕ).

"Мързеливото" оценяване (lazy evaluation) е стратегия на оценяване, която по стандарт стои в основата на работата на всички интерпретатори на Наsкеll. Същността на тази стратегия е, че интерпретаторът оценява даден аргумент на дадена функция само ако стойността на този аргумент е необходима за пресмятането на целия резултат. Ако даден аргумент е съставен (вектор или списък), то се оценяват само тези негови компоненти, чиито стойности са необходими от гледна точка на получаването на резултата. При това дублиращите се подизраза се оценяват по не повече от един път.

Примери:
switch :: Int -> a -> a -> a
switch n x y
 | n>0 = x
 | otherwise = y


h :: Int -> Int -> Int
h x y = x + x

Това, което характеризира оценяването в Haskell, освен обстоятелството, че аргументите се оценяват по не повече от един път, е редът, 
в който се прилагат функции, когато има възможност за избор.
- Оценяването се извършва в посока от външните към вътрешните изрази.
В ситуации от типа на f1 e1 (f2 e2 10) ,където едно прилагане на функция включва друго, външното обръщение f1 e1 (f2 e2 10) се 
избира за оценяване.
- В останалите случаи оценяването се извършва в посока от ляво на дясно.
В израза f1 e1 + f2 e2 трябва да бъдат оценени и двата подчертани израза. При това най-напред се оценява левият израз f1 e1


4. ДАЙТЕ ПРИМЕР ЗА ДЕФИНИЦИЯ НА ЕКЗЕМПЛЯР НА КЛАС С КОНТЕКСТ. ОБЯСНЕТЕ НАКРАТКО СМИСЪЛА НА ТАЗИ ДЕФИНИЦИЯ.

Най-важно (определящо) за класа Eq е наличието на функцията == от тип a -> a -> Bool, която проверява дали два елемента на даден тип a, 
който е екземпляр на Eq, са равни:

Примерня дефиниция:
elem :: Eq a => a -> [a] -> Bool
elem _ [] = False
elem x (y:ys) = (x == y) || (elem x ys)

Функцията elem проверява дали даден елемент се съдържа в списък. Ако елементът е в списъка, функцията връща 
True, в противен случай връща False.


5. ОПИШЕТЕ СТРАТЕГИЯТА ЗА ТЪРСЕНЕ НА ПЪТ В ГРАФ В ДЪЛБОЧИНА (DEPTH-FIRST SEARCH) 

При търсенето в дълбочина фронтът се обработва като стек. В началото на търсенето фронтът има вида [[Start]].
 Ако на текущата стъпка фронтът е [p1, p2, ... , pn], то:
  - избира се първият елемент на фронта (p1);
  - ако пътят p1 е достигнал целта, търсенето се прекратява и p1 се връща като резултат;
  - ацикличните пътища p1', p1", … , p1(k), които продължават с една дъга p1, се добавят в началото на стека (преди p2), 
  т.е. фронтът придобива вида [p1', p1'', … , p1(k), p2, ... , pn] и се преминава към следващата стъпка;
  - p2 се обработва едва след като се изследват всички пътища, които са продължения на p1


6. ДАЙТЕ ПРИМЕР ЗА ЧАСТИЧНО ПРИЛАГАНЕ НА ФУНКЦИЯ В HASKELL. ОБЯСНЕТЕ КАКЪВ Е ТИПЪТ НА РЕЗУЛТАТА ОТ ЧАСТИЧНОТО ПРИЛАГАНЕ ВЪВ ВАШИЯ ПРИМЕР 

Нека разгледаме като пример функцията за умножение на две числа, дефинирана както следва:

multiply :: Int -> Int -> Int
multiply x y = x*y

Ако тази функция бъде приложена към два аргумента, като резултат ще се получи число, например multiply 2 3 връща резултат 6
Ако multiply се приложи към един аргумент, например числото 2, в резултат ще се получи функция на един аргумент y, която удвоява 
аргумента си, т.е. функция, която може да бъде записана като (\y -> 2*y). Следователно, всяка функция на два или повече аргумента 
може да бъде приложена частично към по-малък брой аргументи. Тази идея дава богативъзможности за конструиране на функции като оценки 
на обръщения към други функции.

Ако дадена функция f е от тип
t1 -> t2 -> … -> tn -> t
и тази функция е приложена към аргументи
e1 :: t1, e2 :: t2, ... , ek :: tk (където k ≤ n),
то типът на резултата се определя чрез изключване на типовете t1, t2, … , tk:
t1 -> t2 -> ... -> tk -> tk+1 -> ... -> tn -> t,
т.е. резултатът е от тип
tk+1 -> tk+2 -> ... -> tn -> t


7. ОБЯСНЕТЕ ПОНЯТИЕТО "АЛГЕБРИЧЕН ТИП" В ЕЗИКА HASKELL. ДАЙТЕ ДВА ПРИМЕРА ЗА ДЕФИНИЦИИ НА ПОЛИМОРФНИ АЛГЕБРИЧНИ ТИПОВЕ.

Алгебричните типове са съставни типове данни, дефинирани от програмиста. Дефиницията на един алгебричен тип започва с ключовата 
дума data, след която се записват името на типа, знак за равенство и конструкторите на типа. Името на типа и имената на 
конструкторите задължително  започват с главни букви. Алгебричните типове в Haskell се делят на два вида - изброени и производни типове.

Примери за полиморфни алгебрични типове:
Pr 1 2 :: Pairs Int
Pr [ ] [2] :: Pairs [Int]
Pr [ ] [ ] :: Pairs [a]

Дефиниция на функция, която проверява дали са равни двете части на дадена двойка:
equalPair :: Eq a => Pairs a -> Bool
equalPair (Pr x y) = (x==y)


8. ОБЯСНЕТЕ ПОНЯТИЕТО "ГЕНЕРИЧНА ФУНКЦИЯ", ДАЙТЕ ПРИМЕР ЗА ДЕФИНИЦИЯ НА ГЕНЕРИЧНА ФУНКЦИЯ В ЕЗИКА HASKELL.

Генеричните функции, например == (проверка за равенство), + (събиране на числа от един и същ тип) и show 
(конвертиране на число, булева стойност и др. в низ), могат да бъдат прилагани към данни от много типове, но 
за различните типове в действителност се използват различни дефиниции (различни методи на генеричната функция)

Num a => a -> a -> a
reverseList :: [a] -> [a]
reverseList [] = []
reverseList (x:xs) = reverseList xs ++ [x]



9. Обяснете понятието „полиморфна функция“. Дайте два примера за полиморфни функции в езика Haskell.
  Полиморфната функция в езика Haskell е функция, която може да работи с различни типове данни. Това означава, че функцията може да бъде 
  използвана с аргументи от различни типове, без да е необходимо да се дефинират отделни версии на функцията за всеки отделен тип.

Примери:
length - функцията length приема списък и връща броя на елементите в списъка. Тя е полиморфна, защото може да работи със списъци от различни типове данни

length :: [a] -> Int
length [] = 0
length (_:xs) = 1 + length xs

head - функцията head приема списък и връща първия елемент от списъка. Тя също е полиморфна, тъй като може да работи с различни типове данни.

head :: [a] -> a
head (x:_) = x
head [] = error "Empty list"

Полиморфните функции в Haskell позволяват повторно използване на код и осигуряват гъвкавост и универсалност при работа с различни типове данни.


10. Дайте пример за дефиниция на алгебричен тип като производен екземпляр на множество класове. Обяснете накратко значението на тази дефиниция.
  
  Възможно е да се дефинира нов алгебричен тип като например Season или Shape, който да бъде екземпляр на множество вградени класове.

Примери:

data Season = Spring | Summer | Autumn | Winter
 deriving (Eq,Ord,Enum,Show,Read)
Тук Name е синоним на String, а Age е синоним на Int

data Shape = Circle Float |
 Rectangle Float Float
 deriving (Eq,Show,Read)


11. Обяснете понятието „дефиниране на функция на функционално ниво“. Дайте пример за дефиниция на функция на функционално ниво.
  
  Дефинирането на някаква функция на функционално ниво предполага действието на тази функция да се опише не в термините на резултата,който 
  връща тя при прилагане към подходящо множество от аргументи, а като директно се посочи връзката ѝ с други функции.

Пример:

twice :: (a -> a) -> (a -> a)
twice f = (f . f)


12. Обяснете понятието „алгебричен тип“ в езика Haskell. Дайте два примера за дефиниции на различни видове алгебрични типове.
  
  Алгебричните типове са съставни типове данни, дефинирани от програмиста. Дефиницията на един алгебричен тип започва с ключовата дума data, 
  след която се записват името на типа, знак за равенство и конструкторите на типа. Името на типа и имената на конструкторите задължително 
  започват с главни букви. Алгебричните типове в Haskell се делят на два вида - изброени и производни типове.

Пример за изброени типове:
data Day = Monday | Tuesday | Wednesday | Thursday | Friday | Saturday | Sunday

Пример за производни типове:
data People = Person Name Age
type Name = String
type Age = Int


13. Опишете накратко стратегията за търсене на път в граф в дълбочина (depth-first search).
  
  При търсенето в дълбочина фронтът се обработва като стек. В началото на търсенето фронтът има вида [[Start]].

 Ако на текущата стъпка фронтът е [p1, p2, ... , pn], то:
  - избира се първият елемент на фронта (p1);
  - ако пътят p1 е достигнал целта, търсенето се прекратява и p1 се връща като резултат;
  - ацикличните пътища p1', p1", … , p1(k), които продължават с една дъга p1, се добавят в началото на стека (преди p2), т.е. 
    фронтът придобива вида [p1', p1'', … , p1(k), p2, ... , pn] и се преминава към следващата стъпка;
  - p2 се обработва едва след като се изследват всички пътища, които са продължения на p1


14. Как се дефинират класове в Haskell? Дайте пример за дефиниция на клас.
  Най-общо, понятието клас в езика Haskell се определя като колекция от типове, за които се поддържа множество додефинирани операции, 
  наречени методи.

  Например, за функцията elem, която е „вградена“ в Haskell,
  може да се предположи, че е от тип 
  elem :: a -> [a] -> Bool

  Множеството (колекцията) от типове, за които са дефинирани съответно множество от функции, се нарича клас от/на типове (type class) или 
  накратко клас.

  Например, множеството от типове, за които е дефинирана функцията за проверка на равенство (==), се означава като клас Eq.

  allEqual :: Eq a => a -> a -> a -> Bool
  allEqual m n p = (m==n) && (n==p)
  
  elem :: Eq a => a -> [a] -> Bool
  elem _ [] = False
  elem x (y:ys) = (x == y) || (elem x ys)

  
  заглавната (декларативната) част на 
  дефиницията на клас има следния общ вид:
  class Name ty where
  ... signature involving the type variable ty ...
  (Декларацията включва името на класа (Visible) и т. нар. 
  signature (сигнатура; „подпис“) на класа, т.е. списък от имената и 
  типовете на функциите, които еднозначно определят 
  (характеризират) класа – това са функциите, които следва 
  задължително да бъдат дефинирани за всички типове, които са 
  екземпляри на този клас)

Дефиниции по подразбиране:
  class Eq a where
  (==), (/=) :: a -> a -> Bool
  x /= y = not (x==y)
  x == y = not (x/=y)
    (Към операцията за сравнение с цел проверка на равенство се 
    добавя и проверката за неравенство (различие). Освен това са 
    включени и дефиниции по подразбиране на /= чрез == и на ==
    чрез /=)