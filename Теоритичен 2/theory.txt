1. Характеризирайте накратко структурата от данни „опашка“.
  Опашкате е структура от данни, която представлява последователност от елементи, като винаги добавя и премахва елементи от единия край на структурата, наречен "опашката". Опашката следва принципа "първи влязъл, първи излязъл".

Структурата от данни "опашка" може да бъде представена чрез списък от елементи в Хаскел. Тя се моделира като два списъка - един за 
входящите елементи и един за изходящите елементи. Елементите се добавят към задния край на опашката с помощта на операцията за 
конкатенация на списъци "++", а се премахват от предния край с помощта на операцията "tail" за получаване на опашката без първия елемент. (chatgpt)

Опашката е крайна редица от елементи от един и същ тип. Операцията включване на елемент е допустима само за единия (например десния) край на 
редицата, който се нарича край на опашката. Операцията изключване на елемент е допустима само за другия (левия) край на редицата, който се нарича 
начало на опашката. Възможен е пряк достъп само до елемента, намиращ се в началото на опашката. При описаната организация на логическите операции, 
последният включен в опашката елемент се изключва последен, а първият – първи. Затова опашката се определя още като структура от данни „пръв 
влязъл – пръв излязъл“ (first in – first out, FIFO).  (ПРЕЗЕНТАЦИЯ!!!!!!!)


2. Обяснете същността на „мързеливото“ оценяване (lazy evaluation) в езика Haskell. Дайте поне два примера, които илюстрират различни аспекти 
на „мързеливото“ оценяване.
  "Мързеливото" оценяване (lazy evaluation) е стратегия на оценяване, която по стандарт стои в основата на работата на всички интерпретатори на 
  Наsкеll. Същността на тази стратегия е, че интерпретаторът оценява даден аргумент на дадена функция само ако стойността на този аргумент е 
  необходима за пресмятането на целия резултат. Ако даден аргумент е съставен (вектор или списък), то се оценяват само тези негови компоненти, 
  чиито стойности са необходими от гледна точка на получаването на резултата. При това дублиращите се подизраза се оценяват по не повече от един 
  път.

Примери:
switch :: Int -> a -> a -> a
switch n x y
 | n>0 = x
 | otherwise = y

h :: Int -> Int -> Int
h x y = x + x

3. Обяснете понятието „полиморфна функция“. Дайте два примера за полиморфни функции в езика Haskell.
  Полиморфната функция в езика Haskell е функция, която може да работи с различни типове данни. Това означава, че функцията може да бъде 
  използвана с аргументи от различни типове, без да е необходимо да се дефинират отделни версии на функцията за всеки отделен тип.

Примери:
length - функцията length приема списък и връща броя на елементите в списъка. Тя е полиморфна, защото може да работи със списъци от различни типове данни

length :: [a] -> Int
length [] = 0
length (_:xs) = 1 + length xs

head - функцията head приема списък и връща първия елемент от списъка. Тя също е полиморфна, тъй като може да работи с различни типове данни.

head :: [a] -> a
head (x:_) = x
head [] = error "Empty list"

Полиморфните функции в Haskell позволяват повторно използване на код и осигуряват гъвкавост и универсалност при работа с различни типове данни.


4. Дайте пример за дефиниция на алгебричен тип като производен екземпляр на множество класове. Обяснете накратко значението на тази дефиниция.
  Възможно е да се дефинира нов алгебричен тип като например Season или Shape, който да бъде екземпляр на множество вградени класове.

Примери:

data Season = Spring | Summer | Autumn | Winter
 deriving (Eq,Ord,Enum,Show,Read)
Тук Name е синоним на String, а Age е синоним на Int

data Shape = Circle Float |
 Rectangle Float Float
 deriving (Eq,Show,Read)


5. Обяснете понятието „дефиниране на функция на функционално ниво“. Дайте пример за дефиниция на функция на функционално ниво.
  Дефинирането на някаква функция на функционално ниво предполага действието на тази функция да се опише не в термините на резултата,който 
  връща тя при прилагане към подходящо множество от аргументи, а като директно се посочи връзката ѝ с други функции.

Пример:

twice :: (a -> a) -> (a -> a)
twice f = (f . f)


6. Обяснете понятието „алгебричен тип“ в езика Haskell. Дайте два примера за дефиниции на различни видове алгебрични типове.
  Алгебричните типове са съставни типове данни, дефинирани от програмиста. Дефиницията на един алгебричен тип започва с ключовата дума data, 
  след която се записват името на типа, знак за равенство и конструкторите на типа. Името на типа и имената на конструкторите задължително 
  започват с главни букви. Алгебричните типове в Haskell се делят на два вида - изброени и производни типове.

Пример за изброени типове:
data Day = Monday | Tuesday | Wednesday | Thursday | Friday | Saturday | Sunday

Пример за производни типове:
data People = Person Name Age
type Name = String
type Age = Int


7. Опишете накратко стратегията за търсене на път в граф в дълбочина (depth-first search).
  При търсенето в дълбочина фронтът се обработва като стек. В началото на търсенето фронтът има вида [[Start]].

 Ако на текущата стъпка фронтът е [p1, p2, ... , pn], то:
  - избира се първият елемент на фронта (p1);
  - ако пътят p1 е достигнал целта, търсенето се прекратява и p1 се връща като резултат;
  - ацикличните пътища p1', p1", … , p1(k), които продължават с една дъга p1, се добавят в началото на стека (преди p2), т.е. 
    фронтът придобива вида [p1', p1'', … , p1(k), p2, ... , pn] и се преминава към следващата стъпка;
  - p2 се обработва едва след като се изследват всички пътища, които са продължения на p1


8. Как се дефинират класове в Haskell? Дайте пример за дефиниция на клас.
  Най-общо, понятието клас в езика Haskell се определя като колекция от типове, за които се поддържа множество додефинирани операции, 
  наречени методи.

  Например, за функцията elem, която е „вградена“ в Haskell,
  може да се предположи, че е от тип 
  elem :: a -> [a] -> Bool

  Множеството (колекцията) от типове, за които са дефинирани съответно множество от функции, се нарича клас от/на типове (type class) или 
  накратко клас.

  Например, множеството от типове, за които е дефинирана функцията за проверка на равенство (==), се означава като клас Eq.

  allEqual :: Eq a => a -> a -> a -> Bool
  allEqual m n p = (m==n) && (n==p)
  
  elem :: Eq a => a -> [a] -> Bool
  elem _ [] = False
  elem x (y:ys) = (x == y) || (elem x ys)

  
  заглавната (декларативната) част на 
  дефиницията на клас има следния общ вид:
  class Name ty where
  ... signature involving the type variable ty ...
  (Декларацията включва името на класа (Visible) и т. нар. 
  signature (сигнатура; „подпис“) на класа, т.е. списък от имената и 
  типовете на функциите, които еднозначно определят 
  (характеризират) класа – това са функциите, които следва 
  задължително да бъдат дефинирани за всички типове, които са 
  екземпляри на този клас)

Дефиниции по подразбиране:
  class Eq a where
  (==), (/=) :: a -> a -> Bool
  x /= y = not (x==y)
  x == y = not (x/=y)
    (Към операцията за сравнение с цел проверка на равенство се 
    добавя и проверката за неравенство (различие). Освен това са 
    включени и дефиниции по подразбиране на /= чрез == и на ==
    чрез /=)