ТЕСТ 1 НЕЧЕТНИ НОМЕРА

1. Обяснете понятието „рекурсивен изчислителен процес“. Дефинирайте функция на езика Haskell, 
която генерира рекурсивен изчислителен процес, и обяснете предназначението на тази функция.


2. Опишете общия вид на дефиниция на функция с условия (guards) в езика Haskell 
и процеса на оценяване на обръщение към такава функция.

Условието („охраняващ“ израз, guard) е Булев израз. Условия 
се използват, когато трябва да се опишат различни случаи в 
дефиницията на функция.


4. Кои от следните конструкции са коректно дефинирани (валидни) списъци в Haskell? Посочете типовете на валидните списъци, 
а за останалите обяснете защо не са валидни.

(а) [’X’,”X”]

(б) [[[1,2,3,4,5]],[]]

(в) [(2023,”Hi”),(2023,”Hi”,”Everybody”)]

(г) [[”2023”,”Hi”],[”2023”,”Hi”,”Everybody”]]


а) списъкът трябвa да e от един тип

б) Num a => [[[a]]]

в) списъкът трябва да е от един тип

г) [[String]]


5. Каква е областта на действие на променливите в езика Haskell? Дайте поне два примера, 
илюстриращи дефиниции на променливи с различни области на действие.



6. Обяснете понятието „образец“ (pattern) в Haskell. Дайте примери за поне три типа образци и формулирайте правилата 
за успешното им съпоставяне със съответните аргументи.

Образец - езикова конструкция, с помощта на която се
    описва в обобщен вид отделен възможен случай за даден аргумент
    •Литерал като например 24, ‘f’ или True, даден аргумент се
    съпоставя успешно с такъв образец, ако е равен на неговата
    стойност;
    • Променлива като например x или longVariableName, образец от
    този вид се съпоставя успешно с аргумент с произволна
    стойност;
    • Специален символ за безусловно съпоставяне (wildcard) ‘_’,
    който е съпоставим с произволен аргумент;


7. Дайте пример за дефиниция на функция, в която се използва обща (а не примитивна) рекурсия върху списъци. 
Обяснете каква задача се решава с помощта на тази функция.

Ще дефинираме функцията zip, която трансформира два списъка в списък от двойки от съответните елементи на двата списъка, например:
zip [1,3] [2,4] = [(1,2),(3,4)]
zip [1,2] [‘a’,’b’,’c’] = [(1,’a’),(2,’b’)]
Ще опишем дефиницията на тази функция с рекурсия относно двата аргумента.

zip :: [a] -> [b] -> [(a,b)]
zip (x:xs) (y:ys) = (x,y) : zip xs ys
zip _ _ = []


8. Как се конструира списък чрез определяне на неговия обхват (list comprehension) в езика Haskell? Обяснете общия случай и 
дайте поне два примера (в т.ч. посочете оценките на изразите от Вашите примери).

Синтаксис:
[expr | q1, … , qk] , където expr е израз, а qi може да бъде
- генератор от вида p <- lExp, където p е образец и lExp е израз от списъчен тип
- тест (филтър), bExp, който е булев израз
При това в qi могат да участват променливите, използвани в q1, 
q2, … , qi-1
Пример:
Да предположим, че стойността на ex е [2,4,7]. Тогава записът 
[2*n | n <- ex] означава списъка [4,8,14].